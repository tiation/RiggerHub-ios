(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('module'), require('path'), require('url'), require('uuid'), require('winston')) :
  typeof define === 'function' && define.amd ? define(['exports', 'module', 'path', 'url', 'uuid', 'winston'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.RiggerShared = {}, global.module, global.path, global.url, global.uuid, global.winston));
})(this, (function (exports, module, path, url, uuid, winston) { 'use strict';

  var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
  // =================================================
  // RiggerShared - Environment Configuration Module
  // =================================================
  // Centralized configuration management for environment variables
  // Provides type-safe access to environment variables with defaults


  const require$1 = module.createRequire((typeof document === 'undefined' && typeof location === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : typeof document === 'undefined' ? location.href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('rigger-shared.umd.js', document.baseURI).href)));
  const __filename = url.fileURLToPath((typeof document === 'undefined' && typeof location === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : typeof document === 'undefined' ? location.href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('rigger-shared.umd.js', document.baseURI).href)));
  const __dirname = path.dirname(__filename);

  // Load environment variables if not already loaded
  function loadEnvironmentVariables() {
    try {
      const dotenv = require$1('dotenv');
      
      // Load base .env file
      dotenv.config();
      
      // Load environment-specific file
      const NODE_ENV = "development" || 'development';
      const envFile = `.env.${NODE_ENV}`;
      dotenv.config({ path: path.resolve(__dirname, '../../', envFile) });
      
      // Load local overrides
      dotenv.config({ path: path.resolve(__dirname, '../../', '.env.local') });
    } catch (error) {
      console.warn('Could not load environment variables:', error.message);
    }
  }

  // Initialize environment variables
  loadEnvironmentVariables();

  /**
   * Get environment variable with type conversion and default value
   * @param {string} key - Environment variable key
   * @param {any} defaultValue - Default value if not found
   * @param {'string'|'number'|'boolean'|'json'} type - Type to convert to
   * @returns {any} The environment variable value
   */
  function getEnvVar(key, defaultValue, type = 'string') {
    const value = process.env[key];
    
    if (value === undefined || value === '') {
      return defaultValue;
    }
    
    switch (type) {
      case 'number':
        const num = Number(value);
        return isNaN(num) ? defaultValue : num;
        
      case 'boolean':
        return value.toLowerCase() === 'true';
        
      case 'json':
        try {
          return JSON.parse(value);
        } catch {
          return defaultValue;
        }
        
      default:
        return value;
    }
  }

  /**
   * Validate required environment variables
   * @param {string[]} requiredVars - Array of required variable names
   * @throws {Error} If any required variables are missing
   */
  function validateRequiredVars(requiredVars) {
    const missing = requiredVars.filter(key => !process.env[key]);
    if (missing.length > 0) {
      throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
    }
  }

  // Environment Configuration Object
  const config = {
    // Environment Information
    environment: {
      NODE_ENV: getEnvVar('NODE_ENV', 'development'),
      BUILD_TIME: getEnvVar('BUILD_TIME', new Date().toISOString()),
      VERSION: getEnvVar('VERSION', '1.0.0'),
      LIBRARY_NAME: getEnvVar('LIBRARY_NAME', '@rigger/shared'),
      
      get isDevelopment() {
        return this.NODE_ENV === 'development';
      },
      
      get isProduction() {
        return this.NODE_ENV === 'production';
      },
      
      get isStaging() {
        return this.NODE_ENV === 'staging';
      },
      
      get isTest() {
        return this.NODE_ENV === 'test';
      }
    },
    
    // API Configuration
    api: {
      BASE_URL: getEnvVar('API_BASE_URL', 'http://localhost:3000/api'),
      VERSION: getEnvVar('API_VERSION', 'v1'),
      TIMEOUT: getEnvVar('API_TIMEOUT', 30000, 'number'),
      
      get fullUrl() {
        return `${this.BASE_URL}/${this.VERSION}`;
      }
    },
    
    // Database Configuration
    database: {
      URL: getEnvVar('DATABASE_URL', ''),
      POOL_MIN: getEnvVar('DATABASE_POOL_MIN', 2, 'number'),
      POOL_MAX: getEnvVar('DATABASE_POOL_MAX', 10, 'number'),
      SSL: getEnvVar('DATABASE_SSL', false, 'boolean'),
      SSL_REJECT_UNAUTHORIZED: getEnvVar('DATABASE_SSL_REJECT_UNAUTHORIZED', true, 'boolean'),
      
      get poolConfig() {
        return {
          min: this.POOL_MIN,
          max: this.POOL_MAX,
          ssl: this.SSL ? { rejectUnauthorized: this.SSL_REJECT_UNAUTHORIZED } : false
        };
      }
    },
    
    // Supabase Configuration  
    supabase: {
      URL: getEnvVar('SUPABASE_URL', ''),
      ANON_KEY: getEnvVar('SUPABASE_ANON_KEY', ''),
      SERVICE_ROLE_KEY: getEnvVar('SUPABASE_SERVICE_ROLE_KEY', ''),
      
      get isConfigured() {
        return this.URL && this.ANON_KEY;
      }
    },
    
    // Redis Configuration
    redis: {
      URL: getEnvVar('REDIS_URL', 'redis://localhost:6379'),
      PASSWORD: getEnvVar('REDIS_PASSWORD', ''),
      DB: getEnvVar('REDIS_DB', 0, 'number'),
      SSL: getEnvVar('REDIS_SSL', false, 'boolean'),
      
      get connectionConfig() {
        return {
          url: this.URL,
          password: this.PASSWORD || undefined,
          db: this.DB,
          tls: this.SSL ? {} : undefined
        };
      }
    },
    
    // Logging Configuration
    logging: {
      LEVEL: getEnvVar('LOG_LEVEL', 'info'),
      FORMAT: getEnvVar('LOG_FORMAT', 'json'),
      FILE: getEnvVar('LOG_FILE', 'logs/rigger-shared.log'),
      MAX_SIZE: getEnvVar('LOG_MAX_SIZE', '100mb'),
      MAX_FILES: getEnvVar('LOG_MAX_FILES', 10, 'number'),
      
      get config() {
        return {
          level: this.LEVEL,
          format: this.FORMAT,
          filename: this.FILE,
          maxsize: this.MAX_SIZE,
          maxFiles: this.MAX_FILES
        };
      }
    },
    
    // Feature Flags
    features: {
      DEBUG_MODE: getEnvVar('ENABLE_DEBUG_MODE', false, 'boolean'),
      METRICS_COLLECTION: getEnvVar('ENABLE_METRICS_COLLECTION', true, 'boolean'),
      PERFORMANCE_MONITORING: getEnvVar('ENABLE_PERFORMANCE_MONITORING', true, 'boolean'),
      VERBOSE_LOGGING: getEnvVar('ENABLE_VERBOSE_LOGGING', false, 'boolean'),
      SOURCE_MAPS: getEnvVar('ENABLE_SOURCE_MAPS', false, 'boolean'),
      DEV_TOOLS: getEnvVar('ENABLE_DEV_TOOLS', false, 'boolean'),
      COMPRESSION: getEnvVar('ENABLE_COMPRESSION', true, 'boolean'),
      CACHING: getEnvVar('ENABLE_CACHING', true, 'boolean'),
      HOT_RELOAD: getEnvVar('ENABLE_HOT_RELOAD', false, 'boolean')
    },
    
    // External Services
    services: {
      RIGGER_CONNECT_URL: getEnvVar('RIGGER_CONNECT_URL', 'http://localhost:3001'),
      RIGGER_HUB_URL: getEnvVar('RIGGER_HUB_URL', 'http://localhost:3002'),
      RIGGER_BACKEND_URL: getEnvVar('RIGGER_BACKEND_URL', 'http://localhost:3003')
    },
    
    // Security Configuration
    security: {
      CORS_ENABLED: getEnvVar('CORS_ENABLED', true, 'boolean'),
      CORS_ORIGINS: getEnvVar('CORS_ORIGINS', '*').split(',').map(origin => origin.trim()),
      RATE_LIMIT_ENABLED: getEnvVar('RATE_LIMIT_ENABLED', false, 'boolean'),
      RATE_LIMIT_MAX_REQUESTS: getEnvVar('RATE_LIMIT_MAX_REQUESTS', 100, 'number'),
      RATE_LIMIT_WINDOW_MS: getEnvVar('RATE_LIMIT_WINDOW_MS', 900000, 'number'),
      HELMET_ENABLED: getEnvVar('HELMET_ENABLED', true, 'boolean'),
      SSL_ENABLED: getEnvVar('SSL_ENABLED', false, 'boolean'),
      FORCE_HTTPS: getEnvVar('FORCE_HTTPS', false, 'boolean'),
      HSTS_MAX_AGE: getEnvVar('HSTS_MAX_AGE', 31536000, 'number'),
      
      get corsConfig() {
        return {
          enabled: this.CORS_ENABLED,
          origin: this.CORS_ORIGINS.includes('*') ? true : this.CORS_ORIGINS
        };
      },
      
      get rateLimitConfig() {
        return {
          enabled: this.RATE_LIMIT_ENABLED,
          max: this.RATE_LIMIT_MAX_REQUESTS,
          windowMs: this.RATE_LIMIT_WINDOW_MS
        };
      }
    },
    
    // Performance Settings
    performance: {
      MAX_REQUEST_SIZE: getEnvVar('MAX_REQUEST_SIZE', '10mb'),
      REQUEST_TIMEOUT: getEnvVar('REQUEST_TIMEOUT', 30000, 'number'),
      KEEP_ALIVE_TIMEOUT: getEnvVar('KEEP_ALIVE_TIMEOUT', 5000, 'number')
    },
    
    // Health and Monitoring
    monitoring: {
      HEALTH_CHECK_ENABLED: getEnvVar('HEALTH_CHECK_ENABLED', true, 'boolean'),
      HEALTH_CHECK_ENDPOINT: getEnvVar('HEALTH_CHECK_ENDPOINT', '/health'),
      METRICS_ENABLED: getEnvVar('METRICS_ENABLED', true, 'boolean'),
      METRICS_ENDPOINT: getEnvVar('METRICS_ENDPOINT', '/metrics'),
      ERROR_REPORTING_ENABLED: getEnvVar('ERROR_REPORTING_ENABLED', true, 'boolean'),
      SENTRY_ENABLED: getEnvVar('SENTRY_ENABLED', false, 'boolean'),
      SENTRY_DSN: getEnvVar('SENTRY_DSN', '')
    },
    
    // Testing Configuration
    testing: {
      DATABASE_URL: getEnvVar('TEST_DATABASE_URL', ''),
      MOCK_EXTERNAL_SERVICES: getEnvVar('MOCK_EXTERNAL_SERVICES', false, 'boolean')
    }
  };

  // Export environment validation function
  function validateEnvironment() {
    const errors = [];
    
    // Validate based on environment
    if (config.environment.isProduction) {
      // Production-specific validations
      if (!config.database.URL) {
        errors.push('DATABASE_URL is required in production');
      }
      
      if (!config.supabase.URL || !config.supabase.ANON_KEY) {
        errors.push('Supabase configuration is required in production');
      }
      
      if (!config.security.SSL_ENABLED) {
        console.warn('⚠️  SSL is not enabled in production environment');
      }
    }
    
    if (errors.length > 0) {
      throw new Error(`Environment validation failed:\\n${errors.join('\\n')}`);
    }
    
    console.log(`✅ Environment validation passed for ${config.environment.NODE_ENV} environment`);
  }

  // Shared types and interfaces for the Rigger ecosystem

  /**
   * User types and roles
   */
  const UserRoles = {
    ADMIN: 'admin',
    RIGGER: 'rigger',
    EMPLOYER: 'employer',
    AGENT: 'agent',
    SUPERVISOR: 'supervisor',
  };

  const UserStatus = {
    ACTIVE: 'active',
    INACTIVE: 'inactive',
    SUSPENDED: 'suspended',
    PENDING_VERIFICATION: 'pending_verification',
  };

  /**
   * Job types and categories
   */
  const JobCategories = {
    CONSTRUCTION: 'construction',
    MINING: 'mining',
    OIL_GAS: 'oil_gas',
    MARITIME: 'maritime',
    RENEWABLE_ENERGY: 'renewable_energy',
    TELECOMMUNICATIONS: 'telecommunications',
    ENTERTAINMENT: 'entertainment',
  };

  const JobTypes = {
    FULL_TIME: 'full_time',
    CONTRACT: 'contract',
    CASUAL: 'casual',
    APPRENTICESHIP: 'apprenticeship',
    TEMPORARY: 'temporary',
  };

  const JobStatus = {
    DRAFT: 'draft',
    PUBLISHED: 'published',
    PAUSED: 'paused',
    CLOSED: 'closed',
    FILLED: 'filled',
    CANCELLED: 'cancelled',
  };

  /**
   * Application status
   */
  const ApplicationStatus = {
    SUBMITTED: 'submitted',
    UNDER_REVIEW: 'under_review',
    SHORTLISTED: 'shortlisted',
    INTERVIEW_SCHEDULED: 'interview_scheduled',
    INTERVIEW_COMPLETED: 'interview_completed',
    OFFERED: 'offered',
    ACCEPTED: 'accepted',
    REJECTED: 'rejected',
    WITHDRAWN: 'withdrawn',
  };

  /**
   * Payment and subscription types
   */
  const PaymentStatus = {
    PENDING: 'pending',
    PROCESSING: 'processing',
    COMPLETED: 'completed',
    FAILED: 'failed',
    CANCELLED: 'cancelled',
    REFUNDED: 'refunded',
  };

  const SubscriptionPlans = {
    FREE: 'free',
    BASIC: 'basic',
    PREMIUM: 'premium',
    ENTERPRISE: 'enterprise',
  };

  /**
   * Geographic and location types
   */
  const States = {
    NSW: 'nsw',
    VIC: 'vic',
    QLD: 'qld',
    WA: 'wa',
    SA: 'sa',
    TAS: 'tas',
    ACT: 'act',
    NT: 'nt',
  };

  const Countries = {
    AUSTRALIA: 'australia',
    NEW_ZEALAND: 'new_zealand',
    UNITED_STATES: 'united_states',
    CANADA: 'canada',
    UNITED_KINGDOM: 'united_kingdom',
  };

  /**
   * Safety and compliance types
   */
  const CertificationTypes = {
    WHITE_CARD: 'white_card',
    WORKING_AT_HEIGHTS: 'working_at_heights',
    CONFINED_SPACES: 'confined_spaces',
    FIRST_AID: 'first_aid',
    RIGGING_LICENSE: 'rigging_license',
    CRANE_LICENSE: 'crane_license',
    FORKLIFT_LICENSE: 'forklift_license',
    ELECTRICAL_LICENSE: 'electrical_license',
    WELDING_CERTIFICATE: 'welding_certificate',
  };

  const SafetyRatings = {
    EXCELLENT: 'excellent',
    GOOD: 'good',
    SATISFACTORY: 'satisfactory',
    NEEDS_IMPROVEMENT: 'needs_improvement',
    POOR: 'poor',
  };

  /**
   * Communication and notification types
   */
  const NotificationTypes = {
    JOB_ALERT: 'job_alert',
    APPLICATION_UPDATE: 'application_update',
    MESSAGE: 'message',
    SYSTEM_ANNOUNCEMENT: 'system_announcement',
    PAYMENT_UPDATE: 'payment_update',
    SAFETY_ALERT: 'safety_alert',
    COMPLIANCE_REMINDER: 'compliance_reminder',
  };

  const MessageTypes = {
    TEXT: 'text',
    IMAGE: 'image',
    DOCUMENT: 'document',
    SYSTEM: 'system',
    AUTOMATED: 'automated',
  };

  /**
   * API Response types
   */
  const ApiResponseStatus = {
    SUCCESS: 'success',
    ERROR: 'error',
    WARNING: 'warning',
  };

  const HttpStatusCodes = {
    OK: 200,
    CREATED: 201,
    NO_CONTENT: 204,
    BAD_REQUEST: 400,
    UNAUTHORIZED: 401,
    FORBIDDEN: 403,
    NOT_FOUND: 404,
    CONFLICT: 409,
    VALIDATION_ERROR: 422,
    INTERNAL_SERVER_ERROR: 500,
    SERVICE_UNAVAILABLE: 503,
  };

  /**
   * Monitoring and logging types
   */
  const LogLevels = {
    DEBUG: 'debug',
    INFO: 'info',
    WARN: 'warn',
    ERROR: 'error',
    FATAL: 'fatal',
  };

  const MetricTypes = {
    COUNTER: 'counter',
    GAUGE: 'gauge',
    HISTOGRAM: 'histogram',
    SUMMARY: 'summary',
  };

  /**
   * Feature flags and configurations
   */
  const FeatureFlags = {
    AI_MATCHING: 'ai_matching',
    VIDEO_INTERVIEWS: 'video_interviews',
    REAL_TIME_CHAT: 'real_time_chat',
    MOBILE_PUSH_NOTIFICATIONS: 'mobile_push_notifications',
    ADVANCED_ANALYTICS: 'advanced_analytics',
    PAYMENT_PROCESSING: 'payment_processing',
    BACKGROUND_CHECKS: 'background_checks',
  };

  /**
   * Validation patterns and rules
   */
  const ValidationPatterns = {
    EMAIL: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
    PHONE_AU: /^(\+61|0)[2-9]\d{8}$/,
    ABN: /^\d{11}$/,
    TFN: /^\d{8,9}$/,
    LICENSE_PLATE: /^[A-Z0-9]{2,6}$/,
    POSTCODE_AU: /^\d{4}$/,
  };

  /**
   * Error codes for consistent error handling
   */
  const ErrorCodes = {
    // Authentication & Authorization
    INVALID_CREDENTIALS: 'INVALID_CREDENTIALS',
    TOKEN_EXPIRED: 'TOKEN_EXPIRED',
    INSUFFICIENT_PERMISSIONS: 'INSUFFICIENT_PERMISSIONS',
    ACCOUNT_SUSPENDED: 'ACCOUNT_SUSPENDED',
    
    // Validation
    VALIDATION_ERROR: 'VALIDATION_ERROR',
    MISSING_REQUIRED_FIELD: 'MISSING_REQUIRED_FIELD',
    INVALID_FORMAT: 'INVALID_FORMAT',
    
    // Business Logic
    DUPLICATE_ENTRY: 'DUPLICATE_ENTRY',
    RESOURCE_NOT_FOUND: 'RESOURCE_NOT_FOUND',
    OPERATION_NOT_ALLOWED: 'OPERATION_NOT_ALLOWED',
    QUOTA_EXCEEDED: 'QUOTA_EXCEEDED',
    
    // System
    DATABASE_ERROR: 'DATABASE_ERROR',
    EXTERNAL_SERVICE_ERROR: 'EXTERNAL_SERVICE_ERROR',
    FILE_UPLOAD_ERROR: 'FILE_UPLOAD_ERROR',
    RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',
  };

  /**
   * Default configurations
   */
  const DefaultConfig = {
    pagination: {
      defaultLimit: 20,
      maxLimit: 100,
    },
    fileUpload: {
      maxSizeBytes: 10 * 1024 * 1024, // 10MB
      allowedTypes: ['image/jpeg', 'image/png', 'application/pdf', 'text/plain'],
    },
    security: {
      passwordMinLength: 8,
      sessionTimeout: 30 * 60 * 1000, // 30 minutes
      maxLoginAttempts: 5,
      lockoutDuration: 15 * 60 * 1000, // 15 minutes
    },
    monitoring: {
      metricsFlushInterval: 30000, // 30 seconds
      logLevel: 'info',
      enableTracing: true,
    },
  };

  var Types = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ApiResponseStatus: ApiResponseStatus,
    ApplicationStatus: ApplicationStatus,
    CertificationTypes: CertificationTypes,
    Countries: Countries,
    DefaultConfig: DefaultConfig,
    ErrorCodes: ErrorCodes,
    FeatureFlags: FeatureFlags,
    HttpStatusCodes: HttpStatusCodes,
    JobCategories: JobCategories,
    JobStatus: JobStatus,
    JobTypes: JobTypes,
    LogLevels: LogLevels,
    MessageTypes: MessageTypes,
    MetricTypes: MetricTypes,
    NotificationTypes: NotificationTypes,
    PaymentStatus: PaymentStatus,
    SafetyRatings: SafetyRatings,
    States: States,
    SubscriptionPlans: SubscriptionPlans,
    UserRoles: UserRoles,
    UserStatus: UserStatus,
    ValidationPatterns: ValidationPatterns
  });

  // Shared constants for Rigger ecosystem

  /**
   * API Base URLs
   */
  const API_BASE_URLS = {
    DEVELOPMENT: 'http://localhost:3000/api',
    STAGING: 'https://staging.riggerconnect.tiation.net/api',
    PRODUCTION: 'https://riggerconnect.tiation.net/api',
  };

  /**
   * API Timeout Settings in milliseconds
   */
  const API_TIMEOUTS = {
    CONNECT_TIMEOUT: 5000, // Connection attempts timeout
    READ_TIMEOUT: 10000, // Read response timeout
  };

  /**
   * Default HTTP Headers for API requests
   */
  const DEFAULT_HEADERS = {
    'Accept': 'application/json',
    'Content-Type': 'application/json',
    'Accept-Encoding': 'gzip, deflate, br'
  };

  /**
   * Namespaces for logging and metrics
   */
  const LOGGING_NAMESPACE = 'com.tiation.rigger';
  const METRICS_NAMESPACE = 'com.tiation.metrics';

  /**
   * Events for application monitoring
   */
  const MONITORING_EVENTS = {
    USER_LOGIN_ATTEMPT: 'user.login.attempt',
    USER_LOGIN_SUCCESS: 'user.login.success',
    USER_LOGIN_FAILURE: 'user.login.failure',
    PAGE_VIEW: 'page.view',
    API_CALL: 'api.call',
    API_CALL_SUCCESS: 'api.call.success',
    API_CALL_FAILURE: 'api.call.failure',
  };

  /**
   * Regex patterns for validation
   */
  const VALIDATION_REGEX = {
    EMAIL: /^[^\s@]+@[^\s@]+\.[^\s@]+$/i,
    POSTCODE: /^\d{4}$/, // Australian postcode
    PHONE_NUMBER: /^\(|0(\d{2,4})\)\d{7}$/,
  };

  const APP_FEATURES = {
    ENABLED_FEATURES: ['dark_mode', 'multi_language', 'voice_commands', 'offline_mode'],
  };

  var Constants = /*#__PURE__*/Object.freeze({
    __proto__: null,
    API_BASE_URLS: API_BASE_URLS,
    API_TIMEOUTS: API_TIMEOUTS,
    APP_FEATURES: APP_FEATURES,
    DEFAULT_HEADERS: DEFAULT_HEADERS,
    LOGGING_NAMESPACE: LOGGING_NAMESPACE,
    METRICS_NAMESPACE: METRICS_NAMESPACE,
    MONITORING_EVENTS: MONITORING_EVENTS,
    VALIDATION_REGEX: VALIDATION_REGEX
  });

  /**
   * String utilities
   */
  const StringUtils = {
    // Generate a random string of specified length
    generateRandomString: (length = 10) => {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      let result = '';
      for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    },

    // Convert string to slug (URL-friendly)
    toSlug: (str) => {
      return str
        .toLowerCase()
        .trim()
        .replace(/[^\w\s-]/g, '') // Remove non-word chars
        .replace(/[\s_-]+/g, '-') // Replace spaces and underscores with hyphens
        .replace(/^-+|-+$/g, ''); // Remove leading/trailing hyphens
    },

    // Capitalize first letter of each word
    toTitleCase: (str) => {
      return str.replace(/\w\S*/g, (txt) => 
        txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
      );
    },

    // Truncate string with ellipsis
    truncate: (str, maxLength = 100, suffix = '...') => {
      if (str.length <= maxLength) return str;
      return str.substr(0, maxLength - suffix.length) + suffix;
    },

    // Mask sensitive information (like email, phone)
    maskEmail: (email) => {
      const [localPart, domain] = email.split('@');
      const maskedLocal = localPart.charAt(0) + '*'.repeat(localPart.length - 2) + localPart.slice(-1);
      return `${maskedLocal}@${domain}`;
    },

    maskPhone: (phone) => {
      return phone.replace(/(\d{2})(\d{4})(\d{4})/, '$1****$3');
    },
  };

  /**
   * Date utilities
   */
  const DateUtils = {
    // Format date to Australian format (DD/MM/YYYY)
    formatAustralianDate: (date) => {
      const d = new Date(date);
      return `${d.getDate().toString().padStart(2, '0')}/${(d.getMonth() + 1).toString().padStart(2, '0')}/${d.getFullYear()}`;
    },

    // Get relative time (e.g., "2 hours ago")
    getRelativeTime: (date) => {
      const now = new Date();
      const diff = now - new Date(date);
      const seconds = Math.floor(diff / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);

      if (days > 0) return `${days} day${days > 1 ? 's' : ''} ago`;
      if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
      if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
      return 'Just now';
    },

    // Check if date is business day (Mon-Fri)
    isBusinessDay: (date) => {
      const day = new Date(date).getDay();
      return day >= 1 && day <= 5;
    },

    // Add business days to a date
    addBusinessDays: (date, days) => {
      const result = new Date(date);
      let addedDays = 0;
      
      while (addedDays < days) {
        result.setDate(result.getDate() + 1);
        if (DateUtils.isBusinessDay(result)) {
          addedDays++;
        }
      }
      
      return result;
    },
  };

  /**
   * Validation utilities
   */
  const ValidationUtils = {
    // Validate email format
    isValidEmail: (email) => {
      return ValidationPatterns.EMAIL.test(email);
    },

    // Validate Australian phone number
    isValidAustralianPhone: (phone) => {
      return ValidationPatterns.PHONE_AU.test(phone);
    },

    // Validate Australian postcode
    isValidPostcode: (postcode) => {
      return ValidationPatterns.POSTCODE_AU.test(postcode);
    },

    // Validate ABN (Australian Business Number)
    isValidABN: (abn) => {
      if (!ValidationPatterns.ABN.test(abn)) return false;
      
      // ABN checksum validation
      const weights = [10, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
      let sum = 0;
      
      for (let i = 0; i < 11; i++) {
        sum += (parseInt(abn[i]) * weights[i]);
      }
      
      return sum % 89 === 0;
    },

    // Validate password strength
    validatePasswordStrength: (password) => {
      const minLength = 8;
      const hasUppercase = /[A-Z]/.test(password);
      const hasLowercase = /[a-z]/.test(password);
      const hasNumbers = /\d/.test(password);
      const hasSpecialChar = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);
      
      const score = [
        password.length >= minLength,
        hasUppercase,
        hasLowercase,
        hasNumbers,
        hasSpecialChar
      ].filter(Boolean).length;
      
      return {
        isValid: score >= 3,
        score,
        requirements: {
          minLength: password.length >= minLength,
          hasUppercase,
          hasLowercase,
          hasNumbers,
          hasSpecialChar
        }
      };
    },
  };

  /**
   * Array utilities
   */
  const ArrayUtils = {
    // Remove duplicates from array
    unique: (arr) => [...new Set(arr)],

    // Group array by property
    groupBy: (arr, key) => {
      return arr.reduce((groups, item) => {
        const group = item[key];
        groups[group] = groups[group] || [];
        groups[group].push(item);
        return groups;
      }, {});
    },

    // Chunk array into smaller arrays
    chunk: (arr, size) => {
      const chunks = [];
      for (let i = 0; i < arr.length; i += size) {
        chunks.push(arr.slice(i, i + size));
      }
      return chunks;
    },

    // Shuffle array randomly
    shuffle: (arr) => {
      const shuffled = [...arr];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    },
  };

  /**
   * Object utilities
   */
  const ObjectUtils = {
    // Deep clone object
    deepClone: (obj) => {
      if (obj === null || typeof obj !== 'object') return obj;
      if (obj instanceof Date) return new Date(obj);
      if (obj instanceof Array) return obj.map(item => ObjectUtils.deepClone(item));
      if (typeof obj === 'object') {
        const clonedObj = {};
        for (const key in obj) {
          if (obj.hasOwnProperty(key)) {
            clonedObj[key] = ObjectUtils.deepClone(obj[key]);
          }
        }
        return clonedObj;
      }
    },

    // Remove null/undefined values from object
    removeEmpty: (obj) => {
      const cleaned = {};
      for (const [key, value] of Object.entries(obj)) {
        if (value !== null && value !== undefined && value !== '') {
          cleaned[key] = typeof value === 'object' && !Array.isArray(value) 
            ? ObjectUtils.removeEmpty(value) 
            : value;
        }
      }
      return cleaned;
    },

    // Get nested property safely
    get: (obj, path, defaultValue = undefined) => {
      const keys = path.split('.');
      let result = obj;
      
      for (const key of keys) {
        if (result === null || result === undefined || !(key in result)) {
          return defaultValue;
        }
        result = result[key];
      }
      
      return result;
    },

    // Set nested property
    set: (obj, path, value) => {
      const keys = path.split('.');
      let current = obj;
      
      for (let i = 0; i < keys.length - 1; i++) {
        const key = keys[i];
        if (!(key in current) || typeof current[key] !== 'object') {
          current[key] = {};
        }
        current = current[key];
      }
      
      current[keys[keys.length - 1]] = value;
      return obj;
    },
  };

  /**
   * Number utilities
   */
  const NumberUtils = {
    // Format number as currency (AUD)
    formatCurrency: (amount, currency = 'AUD') => {
      return new Intl.NumberFormat('en-AU', {
        style: 'currency',
        currency: currency,
      }).format(amount);
    },

    // Format number with thousands separator
    formatNumber: (num) => {
      return new Intl.NumberFormat('en-AU').format(num);
    },

    // Generate random number in range
    randomInRange: (min, max) => {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    },

    // Round to specified decimal places
    roundTo: (num, decimals = 2) => {
      return Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
    },
  };

  /**
   * File utilities
   */
  const FileUtils = {
    // Get file extension
    getExtension: (filename) => {
      return filename.split('.').pop().toLowerCase();
    },

    // Format file size
    formatFileSize: (bytes) => {
      if (bytes === 0) return '0 Bytes';
      
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    },

    // Check if file type is image
    isImage: (filename) => {
      const imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg'];
      return imageExtensions.includes(FileUtils.getExtension(filename));
    },

    // Check if file type is document
    isDocument: (filename) => {
      const docExtensions = ['pdf', 'doc', 'docx', 'txt', 'rtf', 'odt'];
      return docExtensions.includes(FileUtils.getExtension(filename));
    },
  };

  /**
   * URL utilities
   */
  const UrlUtils = {
    // Build URL with query parameters
    buildUrl: (baseUrl, params = {}) => {
      const url = new URL(baseUrl);
      Object.keys(params).forEach(key => {
        if (params[key] !== null && params[key] !== undefined) {
          url.searchParams.append(key, params[key]);
        }
      });
      return url.toString();
    },

    // Extract domain from URL
    getDomain: (url) => {
      try {
        return new URL(url).hostname;
      } catch {
        return null;
      }
    },

    // Check if URL is valid
    isValidUrl: (url) => {
      try {
        new URL(url);
        return true;
      } catch {
        return false;
      }
    },
  };

  /**
   * ID and UUID utilities
   */
  const IdUtils = {
    // Generate UUID v4
    generateUUID: () => uuid.v4(),

    // Generate short ID (8 characters)
    generateShortId: () => {
      return Math.random().toString(36).substr(2, 8);
    },

    // Generate numeric ID
    generateNumericId: (length = 6) => {
      return Math.random().toString().substr(2, length);
    },
  };

  /**
   * Environment utilities
   */
  const EnvUtils = {
    // Check if running in development
    isDevelopment: () => "development" === 'development',

    // Check if running in production
    isProduction: () => "development" === 'production',

    // Check if running in test environment
    isTest: () => "development" === 'test',

    // Get environment variable with default
    getEnv: (key, defaultValue = null) => {
      return process.env[key] || defaultValue;
    },
  };

  /**
   * Error utilities
   */
  const ErrorUtils = {
    // Create standardized error object
    createError: (code, message, details = {}) => {
      const error = new Error(message);
      error.code = code;
      error.details = details;
      error.timestamp = new Date().toISOString();
      return error;
    },

    // Check if error is operational (expected) vs programming error
    isOperationalError: (error) => {
      return error.isOperational === true;
    },

    // Serialize error for logging
    serializeError: (error) => {
      return {
        name: error.name,
        message: error.message,
        stack: error.stack,
        code: error.code,
        details: error.details,
        timestamp: error.timestamp || new Date().toISOString(),
      };
    },
  };

  /**
   * Retry utilities
   */
  const RetryUtils = {
    // Retry async operation with exponential backoff
    withRetry: async (operation, maxAttempts = 3, baseDelay = 1000) => {
      let lastError;
      
      for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
          return await operation();
        } catch (error) {
          lastError = error;
          
          if (attempt === maxAttempts) {
            throw error;
          }
          
          // Exponential backoff: baseDelay * 2^(attempt-1)
          const delay = baseDelay * Math.pow(2, attempt - 1);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
      
      throw lastError;
    },
  };

  // Export all utilities as default
  var Utils = {
    StringUtils,
    DateUtils,
    ValidationUtils,
    ArrayUtils,
    ObjectUtils,
    NumberUtils,
    FileUtils,
    UrlUtils,
    IdUtils,
    EnvUtils,
    ErrorUtils,
    RetryUtils,
  };

  const logger = winston.createLogger({
      level: 'info',
      format: winston.format.combine(
          winston.format.timestamp(),
          winston.format.json()
      ),
      transports: [
          new winston.transports.File({ filename: 'error.log', level: 'error' }),
          new winston.transports.File({ filename: 'combined.log' })
      ]
  });

  if ("development" !== 'production') {
      logger.add(new winston.transports.Console({
          format: winston.format.simple()
      }));
  }

  const Logger = {
      info: (message, meta = {}) => logger.info(message, meta),
      error: (message, meta = {}) => logger.error(message, meta),
      warn: (message, meta = {}) => logger.warn(message, meta),
      debug: (message, meta = {}) => logger.debug(message, meta)
  };

  // RiggerShared - Shared Libraries and Utilities
  // Enterprise-grade shared components for the Rigger ecosystem


  // Default export combining all modules
  var index = {
    Types,
    Constants,
    Utils,
  };

  // Version and library information
  const VERSION = '1.0.0';
  const LIBRARY_NAME = '@rigger/shared';

  const LibraryInfo = {
    name: LIBRARY_NAME,
    version: VERSION,
    description: 'Shared libraries and utilities for the Rigger ecosystem',
    author: 'Tiation Technologies',
    homepage: 'https://riggerconnect.tiation.net',
  };

  exports.API_BASE_URLS = API_BASE_URLS;
  exports.API_TIMEOUTS = API_TIMEOUTS;
  exports.APP_FEATURES = APP_FEATURES;
  exports.ApiResponseStatus = ApiResponseStatus;
  exports.ApplicationStatus = ApplicationStatus;
  exports.ArrayUtils = ArrayUtils;
  exports.CertificationTypes = CertificationTypes;
  exports.Countries = Countries;
  exports.DEFAULT_HEADERS = DEFAULT_HEADERS;
  exports.DateUtils = DateUtils;
  exports.DefaultConfig = DefaultConfig;
  exports.EnvUtils = EnvUtils;
  exports.ErrorCodes = ErrorCodes;
  exports.ErrorUtils = ErrorUtils;
  exports.FeatureFlags = FeatureFlags;
  exports.FileUtils = FileUtils;
  exports.HttpStatusCodes = HttpStatusCodes;
  exports.IdUtils = IdUtils;
  exports.JobCategories = JobCategories;
  exports.JobStatus = JobStatus;
  exports.JobTypes = JobTypes;
  exports.LIBRARY_NAME = LIBRARY_NAME;
  exports.LOGGING_NAMESPACE = LOGGING_NAMESPACE;
  exports.LibraryInfo = LibraryInfo;
  exports.LogLevels = LogLevels;
  exports.Logger = Logger;
  exports.METRICS_NAMESPACE = METRICS_NAMESPACE;
  exports.MONITORING_EVENTS = MONITORING_EVENTS;
  exports.MessageTypes = MessageTypes;
  exports.MetricTypes = MetricTypes;
  exports.NotificationTypes = NotificationTypes;
  exports.NumberUtils = NumberUtils;
  exports.ObjectUtils = ObjectUtils;
  exports.PaymentStatus = PaymentStatus;
  exports.RetryUtils = RetryUtils;
  exports.SafetyRatings = SafetyRatings;
  exports.States = States;
  exports.StringUtils = StringUtils;
  exports.SubscriptionPlans = SubscriptionPlans;
  exports.UrlUtils = UrlUtils;
  exports.UserRoles = UserRoles;
  exports.UserStatus = UserStatus;
  exports.VALIDATION_REGEX = VALIDATION_REGEX;
  exports.VERSION = VERSION;
  exports.ValidationPatterns = ValidationPatterns;
  exports.ValidationUtils = ValidationUtils;
  exports.config = config;
  exports.default = index;
  exports.getEnvVar = getEnvVar;
  exports.validateEnvironment = validateEnvironment;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=rigger-shared.umd.js.map
